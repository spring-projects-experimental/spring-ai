[[ChatClient]]
= Chat Client API

The `ChatClient` offers a fluent API for stateless interaction with an AI Model. It supports both a synchronous and reactive programming model.

The fluent API has methods for building up the constituent parts of a xref:api/prompt.adoc#_prompts[Prompt] that is passed to the AI model as input.
The `Prompt` contains the instructional text to guide the AI model's output and behavior. From the API point of view, prompts consist of a collection of messages.

The AI model processes two main types of messages: user messages, which are direct inputs from the user, and system messages, which are generated by the system to guide the conversation.

These messages often contain template placeholders that are substituted at runtime based on user input to customize the response of the AI model to the user input.

There are also Prompt options that can be specified., such as the name of the AI Model to generate content and the temperature setting that controls the randomness or creativity of the generated output.

== Creating a ChatClient

The `ChatClient` is created using a `ChatClient.Builder` object.
You can obtain an autoconfigured `ChatClient.Builder` instance for any xref:api/chatmodel.adoc[ChatModel] Spring Boot autoconfiguration or create one programmatically.

=== Using an autoconfigured ChatClient.Builder

In the most simple use case, Spring AI provides Spring Boot autoconfiguration, creating a prototype `ChatClient.Builder` bean for you to inject into your class.
Here is a simple example of retrieving a String response to a simple user request.

[source,java]
----
@RestController
class MyController {

    private final ChatClient chatClient;

    public MyController(ChatClient.Builder chatClientBuilder) {
        this.chatClient = chatClientBuilder.build();
    }

    @GetMapping("/ai")
    String generation(String userInput) {
        return this.chatClient.prompt()
            .user(userInput)
            .call()
            .content();
    }
}
----

In this simple example, the user input sets the contents of the user message.
The call method sends a request to the AI model, and the context method returns the AI model's response as a String.

=== Create a ChatClient programmatically

You can disable the `ChatClient.Builder` autoconfiguration by setting the property `spring.ai.chat.client.enabled=false`.
This is useful if multiple chat models are used together.
Then create a `ChatClient.Builder` instance for for every `ChatModel` programmatically:

[source,java]
----
ChatModel myChatModel = ... // usually autowired

ChatClient.Builder builder = ChatClient.builder(myChatModel);

// or create a ChatClient with the default builder settings:

ChatClient chatClient = ChatClient.create(myChatModel);
----

== ChatClient Responses

The ChatClient API offers several ways to format the response from the AI Model.

=== Returning a ChatResponse

The response from the AI model is a rich structure defined by the type xref:api/chatmodel.adoc#_chatresponse[ChatResponse].
It includes metadata about how the response was generated and can also contain multiple responses, known as xref:api/chatmodel.adoc#_generation[Generation]s, each with its own metadata.
The metadata includes the number of tokens (each token is approximately 3/4 of a word) used to create the response.
This information is important because hosted AI models charge based on the number of tokens used per request.

An example to return the `ChatResponse` object that contains the metadata is shown below by invoking `chatResponse()` after the `call()` method.

[source,java]
----
ChatResponse chatResponse = chatClient.prompt()
    .user("Tell me a joke")
    .call()
    .chatResponse();
----

=== Returning an Entity

You often want to return an entity class that is mapped from the returned `String`.
The `entity` method provides this functionality.

For example, given the Java record:

[source,java]
----
record ActorFilms(String actor, List<String> movies) {
}
----

You can easily map the AI model's output to this record using the `entity` method, as shown below:

[source,java]
----
ActorFilms actorFilms = chatClient.prompt()
    .user("Generate the filmography for a random actor.")
    .call()
    .entity(ActorFilms.class);
----

There is also an overloaded `entity` method with the signature `entity(ParameterizedTypeReference<T> type)` that lets you specify types such as generic Lists:

[source,java]
----
List<ActorFilms> actorFilms = chatClient.prompt()
    .user("Generate the filmography of 5 movies for Tom Hanks and Bill Murray.")
    .call()
    .entity(new ParameterizedTypeReference<List<ActorsFilms>>() {
    });
----

=== Streaming Responses

The `stream` lets you get an asynchronous response as shown below

[source,java]
----
Flux<String> output = chatClient.prompt()
    .user("Tell me a joke")
    .stream()
    .content();
----

You can also stream the `ChatResponse` using the method `Flux<ChatResponse> chatResponse()`.

TIP: The chunked stream response can not be converted into a Java entities automatically.
Use the xref:api/structured-output-converter.adoc#_structuredoutputconverter[Structured Output Converter] to convert the aggregated response.

== Using defaults and parameters

It is often useful to create a `ChatClient` with default user and/or system text defined at design time.
By design time, we mean creating it at application startup in a `@Configuration` class.
You can then replace the user or system parameters in the main runtime code.

Here is a simple example which defines the system text without using any parameters.
The system text sets the context, instructions, and overall desired behavior for the model's response

== Passing in user and system parameters
