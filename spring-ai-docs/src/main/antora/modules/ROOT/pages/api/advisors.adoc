[[Advisors]]

= Spring AI Advisors API

The Spring AI Advisors API introduces a powerful component called `AroundAdvisor`. 
This component dynamically intercepts chat-completion requests and responses, allowing for transformation or utilization of information within these interactions.

The Advisors are important for a number of reasons:

 - Encapsulation of Recurring Tasks: AroundAdvisors enable the packaging of common GenAI patterns into reusable units.
 - Transformation: They facilitate the augmentation of data sent to Language Models (LLMs) and formatting of responses sent back to clients.
 - Portability: As part of the Spring AI core specification, developers can create reusable transformation components that work across various models and use cases.

The xref:api/chatclient.adoc#_advisor_configuration_in_chatclient[ChatClient API] provides a simple way to configure and use advisors. For example you can enable the built-in chat-memory and question-answer advisors like this:

[source,java]
----
ChatClient.builder(chatModel)
    // Enable the built-in chat-memory and question-answer (RAG) advisors at build time.
    .defaultAdvisors(
        new ChatMemoryAdvisor(chatMemory),
        new QuestionAnswerAdvisor(vectorStore, SearchRequest.defaults())
    )
    .build()
    .prompt()
    // At runtime, assign a conversation ID  and  size to the ChatMemoryAdvisor.
    .advisors(advisor -> advisor.param("chat_memory_conversation_id", "678") 
            .param("chat_memory_response_size", 100)) 
    .user(userText)
    .call();
----

The ChatClient API allows configuring advisors at build time and at runtime as well as providing parameters to the advisors.
You can use some of the provided advisors or implement custom such to meet your specific requirements.

== Core Components

The Advisor API is defined in the `org.springframework.ai.chat.client.advisor.api` package by the pair of `CallAroundAdvisor` and `CallAroundAdvisorChain` interfaces and the corresponding `StreamAroundAdvisor` and `StreamAroundAdvisorChain` pair for the streaming responses.

image::advisors-api-classes.jpg[Advisors API Classes, width=600, align="center"]

The `AdvisedRequest` represents the unsealed Prompt request, while the `AdvisedResponse` represents the Chat Completion response.
Both contain an `AdviserContext` object for sharing state across the advisor chain.

The `nextAroundCall()` and the `nextAroundStream()` are key advisor methods, typically performing these actions:

* Examining the unsealed Prompt data
* Customizing and augmenting the Prompt data
* Invoking the next entity in the advisor chain
* Optionally blocking the request
* Examining the chat completion response
* Throwing exceptions to indicate processing errors

In addition the `getOrder()` method determines the advisor's priority in the chain and the `getName()` method provides a unique identifier for the advisor.

The `Advisor Chain`, created and provided by the Spring AI framework, allows for the sequential invocation of multiple advisors. 
This chain is represented by `CallAroundAdvisorChain` for non-streaming and `StreamAroundAdvisorChain` for streaming scenarios.
You add advisors to the chain using the The xref:api/chatclient.adoc#_advisor_configuration_in_chatclient[ChatClient API].

Following usage flow diagram illustrates the interaction between the advisor chain and the Chat Model:

image::advisors-flow.jpg[Advisors API Flow, width=400, align="left"]

. The Spring AI framework creates an `AdvisedRequest` from user's `Prompt` along with an empty `AdvisorContext` object.
. Each advisor in the chain processes the request, potentially modifying it. Alternatively, it can choose to block the request by not making the call to invoke the next entity. In the latter case, the advisor is responsible for filling out the response.
. The final advisor, provided by the framework, sends the request to the `Chat Model`.
. The Chat Model's response is then passed back through the advisor chain and converted into `AdvisedResponse`. Later includes the shared `AdvisorContext` instance.
. Each advisor can process or modify the response.
. The final `AdvisedResponse` is returned to the client by extracting the `ChatCompletion`.

== Implementing an Advisor

To create an advisor, implement either `CallAroundAdvisor` or `StreamAroundAdvisor` (or both). The key method to implement is `nextAroundCall()` for non-streaming or `nextAroundStream()` for streaming advisors.

=== Logging Advisor Example

[source,java]
----
public class SimpleLoggerAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {

	private static final Logger logger = LoggerFactory.getLogger(SimpleLoggerAdvisor.class);

	@Override
	public String getName() {
		return this.getClass().getSimpleName();
	}

	@Override
	public int getOrder() {
		return 0;
	}

	@Override
	public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {

		logger.debug("BEFORE: {}", advisedRequest);

		AdvisedResponse advisedResponse = chain.nextAroundCall(advisedRequest);

		logger.debug("AFTER: {}", advisedResponse);

		return advisedResponse;
	}

	@Override
	public Flux<AdvisedResponse> aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {

		logger.debug("BEFORE: {}", advisedRequest);

		Flux<AdvisedResponse> advisedResponses = chain.nextAroundStream(advisedRequest);
		
        return new MessageAggregator().aggregateAdvisedResponse(advisedResponses, 
                    advisedResponse -> logger.debug("AFTER: {}", advisedResponse));
	}
}
----

=== Streaming vs Non-Streaming

image::advisors-non-stream-vs-stream.jpg[Advisors Streaming vs Non-Streaming Flow, width=800, align="left"]

* Non-streaming advisors work with complete requests and responses.
* Streaming advisors handle requests and responses as continuous streams, using reactive programming concepts (e.g., Flux for responses).


// TODO - Add a section on how to implement a streaming advisor with blocking and non-blocking code.

[source,java]
----
@Override
public Flux<AdvisedResponse> aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
    
    return  Mono.just(advisedRequest)
            .publishOn(Schedulers.boundedElastic())
            .map(request -> {
                // This can be executed by blocking and non-blocking Threads.
                // Advisor before next section
            })
            .flatMapMany(request -> chain.nextAroundStream(request))
            .map(response -> {
                // Advisor after next section
            });
}
----


=== Best Practices

. Keep advisors focused on specific tasks for better modularity.
. Use the `adviseContext` to share state between advisors when necessary.
. Implement both streaming and non-streaming versions of your advisor for maximum flexibility.
. Carefully consider the order of advisors in your chain to ensure proper data flow.

The Spring AI Advisors API provides a flexible and powerful way to intercept, modify, and enhance AI-driven interactions in your Spring applications. By leveraging this API, developers can create more sophisticated, reusable, and maintainable AI components.